Since my working station is at home and i don't want to install all the applications needed for working on this project, i will create here some notes so i don't have to research at home and can begin programming imidiatly.

So the application needs to receive SMS check if they have a tag, wich can the user choose(Default: "Hey where are you?") and also optional with an identification-code. The id-code will change with every track, but only when the user touches the button, that the device is found. Also there will be a whitelist, so not everybody has the permission to find the device.
If a SMS-Session starts with this application. The application will send the current location + all the options that are available. (Ring, Delete, Track, Lock, Maybe Transfer? For Data Resurrection). The last is optional. I will decide later if i want this feature.
The important are the first three.
So sms-read and write permission is needed.
And also i need the gps location. If it is possible i somehow need to activate gps so i can find the device.
I will need the device-admin permission.
And another permission so donotdisturb or mute won't stop me from ringing the device.

# So first things first SMS.

Permissions:

 <uses-permission android:name="android.permission.SEND_SMS" />
 <uses-permission android:name="android.permission.RECEIVE_SMS" />

Broadcast-Receiver:

<receiver
    android:name="de.nulide.findmydevice.SMSReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
         <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
    </intent-filter>
</receiver>


public class SMSReceiver extends BroadcastReceiver {

        private static final String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED";
        private static final String TAG = "FMD_SMS_RECEIVER";

        @Override
        public void onReceive(Context context, Intent intent) {
            Bundle bundle = intent.getExtras();
            SmsMessage[] msgs;
            String strMessage = "";
            String format = bundle.getString("format");
            // Retrieve the SMS message received.
            Object[] pdus = (Object[]) bundle.get(pdu_type);
            if (pdus != null) {
            // Check the Android version.
            boolean isVersionM =
                        (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M);
            // Fill the msgs array.
            msgs = new SmsMessage[pdus.length];
            for (int i = 0; i < msgs.length; i++) {
                // Check Android version and use appropriate createFromPdu.
                if (isVersionM) {
                    // If Android version M or newer:
                    msgs[i] = SmsMessage.createFromPdu((byte[]) pdus[i], format);
                } else {
                    // If Android version L or older:
                    msgs[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);
                }
            // Build the message to show.
            strMessage += "SMS from " + msgs[i].getOriginatingAddress();
            // Check Who sent the message:

            //Check content of message:


            strMessage += " :" + msgs[i].getMessageBody() + "\n";
            // Log and display the SMS message.
            Log.d(TAG, "onReceive: " + strMessage);
            Toast.makeText(context, strMessage, Toast.LENGTH_LONG).show();
            }
            }

           }
    }



Ok also i need to send SMS the following method

public void smsSendMessage(View view) {
    EditText editText = (EditText) findViewById(R.id.editText_main);
    // Set the destination phone number to the string in editText.
    String destinationAddress = editText.getText().toString();
    // Find the sms_message view.
    EditText smsEditText = (EditText) findViewById(R.id.sms_message);
    // Get the text of the SMS message.
    String smsMessage = smsEditText.getText().toString();
    // Set the service center address if needed, otherwise null.
    String scAddress = null;
    // Set pending intents to broadcast
    // when message sent and when delivered, or set to null.
    PendingIntent sentIntent = null, deliveryIntent = null;
    // Use SmsManager.
    SmsManager smsManager = SmsManager.getDefault();
    smsManager.sendTextMessage
                  (destinationAddress, scAddress, smsMessage,
                                 sentIntent, deliveryIntent);
}


i will need a receiver that gets called on boot. so this service also works when the device restarts.

Now for the geo-location:

<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

private Location getLastBestLocation() {
    Location locationGPS = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
    Location locationNet = mLocationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);

    long GPSLocationTime = 0;
    if (null != locationGPS) { GPSLocationTime = locationGPS.getTime(); }

    long NetLocationTime = 0;

    if (null != locationNet) {
        NetLocationTime = locationNet.getTime();
    }

    if ( 0 < GPSLocationTime - NetLocationTime ) {
        return locationGPS;
    }
    else {
        return locationNet;
    }
}@Override
public void onLocationChanged(Location location) {

    makeUseOfNewLocation(location);

    if(currentBestLocation == null){
        currentBestLocation = location;
    }

    ....
}


/**
 * This method modify the last know good location according to the arguments.
 *
 * @param location The possible new location.
 */
void makeUseOfNewLocation(Location location) {
    if ( isBetterLocation(location, currentBestLocation) ) {
        currentBestLocation = location;
    }
}

....

/** Determines whether one location reading is better than the current location fix
 * @param location  The new location that you want to evaluate
 * @param currentBestLocation  The current location fix, to which you want to compare the new one.
 */
protected boolean isBetterLocation(Location location, Location currentBestLocation) {
    if (currentBestLocation == null) {
        // A new location is always better than no location
        return true;
    }

    // Check whether the new location fix is newer or older
    long timeDelta = location.getTime() - currentBestLocation.getTime();
    boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
    boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
    boolean isNewer = timeDelta > 0;

    // If it's been more than two minutes since the current location, use the new location,
    // because the user has likely moved.
    if (isSignificantlyNewer) {
        return true;
        // If the new location is more than two minutes older, it must be worse.
    } else if (isSignificantlyOlder) {
        return false;
    }

    // Check whether the new location fix is more or less accurate
    int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
    boolean isLessAccurate = accuracyDelta > 0;
    boolean isMoreAccurate = accuracyDelta < 0;
    boolean isSignificantlyLessAccurate = accuracyDelta > 200;

    // Check if the old and new location are from the same provider
    boolean isFromSameProvider = isSameProvider(location.getProvider(),
                                                currentBestLocation.getProvider());

    // Determine location quality using a combination of timeliness and accuracy
    if (isMoreAccurate) {
        return true;
    } else if (isNewer && !isLessAccurate) {
        return true;
    } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
        return true;
    }
    return false;
}

// Checks whether two providers are the same
private boolean isSameProvider(String provider1, String provider2) {
    if (provider1 == null) {
        return provider2 == null;
    }
    return provider1.equals(provider2);
}
https://stackoverflow.com/questions/1513485/how-do-i-get-the-current-gps-location-programmatically-in-android


ok it is not possible to turn on gps programmatically
but i have two options that can work:
See this:
https://stackoverflow.com/questions/6775257/android-location-providers-gps-or-network-provider


ok i have now the location and can read and write sms
now i can't turn on gps but i can find the device location somehow.(best: 6m worst: 1.6km)
only that you now. GSM locations have an accuracy of 1.6km.
This is worse. the network solution, if available gives me 60m. When i can ring the device i might find it.

So. How do i ring?

Uri notification = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
Ringtone r = RingtoneManager.getRingtone(getApplicationContext(), notification);
r.play();

ok, and how do i ring even when dnd or muted?

i can turn off dnd and set sound to max.
how i turn off dnd i can lookup in shiftcal.
https://gitlab.com/Nulide/ShiftCal/-/blob/master/app/src/main/java/de/nulide/shiftcal/receiver/DNDReceiver.java

how to turn sound to max?

AudioManager audioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
audioManager.setStreamVolume (AudioManager.STREAM_MUSIC,audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC),0);


Contacts:

    <uses-permission android:name="android.permission.READ_CONTACTS" />

    ((Button)findViewById(R.id.pick_person)).setOnClickListener( new OnClickListener() {
        @Override
        public void onClick(View v) {
            // user BoD suggests using Intent.ACTION_PICK instead of .ACTION_GET_CONTENT to avoid the chooser
            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
            // BoD con't: CONTENT_TYPE instead of CONTENT_ITEM_TYPE
            intent.setType(ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE);
            startActivityForResult(intent, 1);                
        }
    });


My goal is to have the following functionality as a bare minimum.

- whitelist
- SMS receive&send
- gps/network lookup
- ring

the other options i will create in the future.
but these are essential.


the first page will be the permission page.
in there i will explain which permissions are needed and need to be granted, so that the app functions.
Than after that. the user can set the whitelist, the code.

I know that this is not a secure method, but this service is only in emergency.
To get the location the hacker needs a device to simulate having another number.(knowing this number) + the specific code.
If the device get located. the code will change and a notification will remind the user that he was tracked and by who.

i think it is more secure than googles services. the user needs to remember the code. or write it down or give it to people he trusts.
When they break his trust. the applicationw ill tell him so.

also this application works also when no connection to a network exists.


Design?

the first page is a lot of text with buttons to accept the different permissions.
than the main-page i think i will create tabs. (CODE/Contacts/Settings)
The code page will also be the main page. I will show the current code there and also if all the permissions are granted, the service running, and how many contacts are on the whitelist.
The contact page will contain the whiterlisted contacts and a button("+") to add more. the contacts can be deleted by swipe or by holding them.Will see what i like more.
In settings, there will be options like: turning on/off whitelist, the StartMessage, and things like that.

so i think that's it.


Right now i am also searching my old smartphone the old way. Asking people/police/etc. and spreading flyers.
I hope this applicationwill help the people that are privacy aware to have a possibility to find their smartphones and not losing a lot of money and not having a disadvantage cause they don't use google.
If somebody want's to help me, donations are welcome, as it seems right now i need a new smartphone, for which i don't have the money ^^".
If somebody wants to help developing, you are welcome. And also the users, write issues, test the application, tell me what works and what works not, what you wish, or when somebody develops a feature i cann add it.